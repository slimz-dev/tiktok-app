DCB - vùng dữ liệu là 1 byte
DCW - vùng dữ liệu là 2 byte
DCD - vùng dữ liệu là 4 byte
DCQ - vùng dữ liệu là 8 byte


địa chỉ thanh ghi  0x20001000
giá trị thanh ghi R1 = 6
những tập lệnh bắt buộc
trong Arm được dùng từ thanh ghi số R1 đến R13;

1. Gán giá trị:
MOV R1, #0   	; gán giá trị 0 cho thanh ghi R1
MOV R1, R2	; R1 = R2

2. Cộng
ADD R1,#1	; R1=R1+1
ADD R1,R2	; R1=R1+R2
ADD R1,R2,R3	;R1=R2+R3

3. Trừ
SUB R1,#1	;R1=R1-1
SUB R1,R2	;R1=R1-R2
SUB R1,R2,R3	;R1=R2-R3

ngoài ra còn có lệnh
SUBS	; cho phép trừ số nguyên có dấu signed số nguyên có dấu

4. Nhân
MUL R1,#1	;R1=R1x1
MUL R1,R2	;R1=R1xR2
MUL R1,R2,R3	;R1=R2xR3

NHỮNG PHÉP DÙNG VỚI GIÁ TRỊ CỦA THANH GHI

5. LDR - Load
; Khai báo chuỗi
chuoi  DCD  1,2,3,4		; Mỗi 1 phần tử trong chuỗi sẽ có địa chỉ được tăng lên 4 byte

tức là:
1	địa chỉ là 0x20001000
2	địa chỉ là 0x20001004
3	địa chỉ là 0x20001008

Ví dụ 1 có địa chỉ là 0x20001000 giá trị là 1

LDR R1, chuoi	;Lấy giá trị của phần tử đầu tiên trong chuỗi tức là R1 = 1
LDR R1, =chuoi	;Lấy địa chỉ đầu tiên của chuỗi 0x20001000
LDR R3,=4	;Gán giá trị 4 cho R3=> R3 =4


LDR R2,[R1]	;Lấy giá trị nằm trong địa chỉ R1 đưa vào R1 =>R2=1
LDR R2,[R1,R3]	;Lấy địa chỉ R1+R3 sau đó lấy giá trị nằm trong địa chỉ R1+R3 gán vào R2
		
LDR R2, [R1], #4	;Lấy giá trị giá trị nằm địa chỉ R1 + 4 sau đó gán vào cho R2


6. Nhãn	;Dùng để đánh dấu một đoạn chương trình
Có hai loại nhãn

- Câu lệnh nhảy bất kỳ 
B tên_nhãn	; Nhảy bất kỳ, không cần điều kiện

- Câu lệnh nhảy có điều kiện
	Trước các câu lệnh nhảy có điều kiện luôn luôn có lệnh so sánh CMP
CMP R1,#0	; So sánh R1 với 0
CMP R1,R2	;So sánh R1 với R2

Bxx tên_nhãn	; Nhảy có điều kiện
BEQ tên_nhãn	; Nếu bằng thì nhảy đến nhãn
BNE tên_nhãn	; Nếu khác thì nhảy đến nhãn
BCC tên_nhãn	;Nếu <0 thỉ nhảy đến nhãn
BHI tên_nhãn	;Nếu >=0 thì nhảy đến nhãn 
BLS tên_nhãn	;Nếu <=0 thỉ nhảy đến nhãn

BGE tên_nhãn	;Nếu >= thì nhảy
BLT tên_nhãn	;Nếu < thì nhảy
BGT tên_nhãn	;Nếu > thì nhảy
BLE tên_nhãn	; Nếu <= thì nhảy


7. Dịch bit
LSL R1, #2	;Dịch trái 2 bít
LSR R1,#1	;Dịch phải 1 bít

R1 = 4 có dạng 00000100 thì câu lệnh LSL R1,#2 =>  00010000




PHẦN 2, CẤU TRÚC TẬP LỆNH

I. Chỉ dẫn của trình biên dịch
1. THUMB (. thumb) chỉ ra mã lệnh sử dụng tập lệnh thumb theo chuẩn AUL
2. CODE 16 (. code 16) chỉ ra mã hợp ngữ mà lệnh thumb theo cú pháp trước AUL
3. AREA chỉ dẫn cho trình biên dịch tạo ra vùng nhớ dành cho mã lệnh hay dữ liệu
4. SPACE xác lập sẵn vùng nhớ và điền vào đó giá trị 0
5. FILL xác lập vùng nhớ và điền vào giá trị cho trước
6. ALIGN sắp đặt các giá trị vào ô nhớ có độ rộng ngang nhau bằng cách thêm 0 hoặc lệnh NOP
; Sau câu lệnh ALIGN thì tiến hành khai báo dữ liệu
	ALIGN
	chuoi DCD 1, 2, 3, 4, 5
7. EXPORT khai báo một nhãn có thể sử dụng bởi linker để tham chiếu tới một hàm hoặc 
một thư viện khác
8. IMPORT khai báo một nhãn tham chiếu từ một đối tượng được sử dụng bởi linker
dùng để khai báo các file bên ngoài
9. LTORG xác định một vùng nhớ tức thời, dùng để chứa các dữ liệu là hằng số hay các giá trị
cho câu lệnh LDR

10. READONLY	chỉ cho phép đọc

II. Tập lệnh
1. MLA 	; nhân tổ hợp
	MLA R3,R2,R1,R4	; Không thêm được giá trị trực tiếp vào (MLA R1,#2,R1,R4 là sai)
	// R3 = (R2*R1)+R4
	MLS R3,R2,R1,R4
	// R3=R4 - (R2*R1)
	RSB R1,R2,#3
	//R1 = - R2 + 3

2. Câu lệnh rẽ nhánh
+ B {<cond>} lable		;Câu lệnh rẽ nhánh
+ BL {<cond>} lable	;Câu lệnh rẽ nhánh với liên kết, thường sử dụng để gọi hàm
+ BX {<cond>} Rm		; Câu lệnh rẽ nhánh thay thổi
+ BLX {<cond>} lable 	;Câu lệnh rẽ nhánh thay đổi với liên kết

3. Nhóm lệnh điều kiện
ADDEQ R0,R1,R2	;Nếu cờ Z được bật thì R0 = R1 + R2
CBZ		;Lệnh so sánh toán hạng đích bằng 0
CBNZ		;Lệnh so sánh toán hạng đích khác 0

CMP R0,#1	;So sánh R0 với 1
ITE EQ		;Câu lệnh tiếp theo được thực hiện nếu cờ Z được bật
ITE NE		;Câu lệnh tiếp theo được thực hiện nếu cờ Z được clear


MOVEQ R3,#2	;R3 = 2
MOVNE R3,#1	;R3=1


Câu lệnh 1 điều kiện
 
IT EQ
ADDEQ  R0,R0,R1

Câu lệnh 2 điều kiện
OTE GE
ADDGE R0,R0,R1	;Bắt buộc có 2 điều kiện và chạy khi đúng
ADDLE R0,R0,R1	;Chạy khi điều kiện sai


4.Cấu trúc chương trình con
test PROC		;Câu lệnh mở hàm
// cú pháp câu lệnh
      MOVE R1,#4
      BX LR	;Bắt buộc phải có
       ENDP    	; Kết thúc chương trình con

5. Lệnh ngắt
SWI &11	; Tương ứng với lệnh exit(1)
stop B stop; Chạy đến khi dừng

6. Cấu trúc rẽ nhánh và lặp
; Câu lệnh không dấu 
if (G>7) {
Hamso();
}

LDR R2,=G		;Lấy địa chỉ của G
LDR R0,[R2]		;Lấy giá trị của địa chỉ R2 vào R0 
CMP R0,#7		; So sánh R0 với 7 (G với 7)
BLS next1			; Nếu R0 <=  7 thì nhảy đến next1
BL hamso			; Nếu R0>7 thì nhảy vào hamso90
next1
....

if (G<7) {
Hamso();
}

LDR R2,=G		;Lấy địa chỉ của G
LDR R0,[R2]		;Lấy giá trị của địa chỉ R2 vào R0 
CMP R0,#7		; So sánh R0 với 7 (G với 7)
BHS next2		; Nếu R0 >=  7 thì nhảy đến next2
BL hamso			; Nếu R0<7 thì nhảy vào hamso90
next2


//////////////////////////////
Câu lệnh có dấu 

if (G<7) { nhỏ hơn dùng BGE; lớn hơn BLE
Hamso();
}

LDR R2,=G		;Lấy địa chỉ của G
LDR R0,[R2]		;Lấy giá trị của địa chỉ R2 vào R0 
CMP R0,#7		; So sánh R0 với 7 (G với 7)
BGE next1		; Nếu R0 >=  7 thì nhảy đến next1
BL hamso			; Nếu R0<7 thì nhảy vào hamso90
next1
....

///////////////////////

Câu lệnh If .... else

if (G1>G2){
hamso1();
}
else
{hamso2();
}

/////////
Câu lệnh không dấu

LDR R2, =G1	;Lấy địa chỉ G1 gán vào R2;
LDR R0, [R2]	; R0 = giá trị của G1
LDR R2, =G2	; Lấy địa chỉ G2 gán vào R2;
LDR R1,[R2]	;R1 = giá trị của G2
CMP R0,R1	; So sánh R0 với R1
BHI high		;(so sánh không dấu) G1>G2 nhảy đến nhãn high; Nếu có dấu BLE
low BL hamso2	; ngược lại G1<=G2	nhảy đến nhãn hamso2
B next		; chạy xong rồi sẽ chuyển đến next
high BL hamso1	;Tính toán cho G1>G2 nhảy đến hamso1
......
next


7. Câu lệnh switch

CMP R1,giá_trị1
BQE ham1
CMP R1,giá_trị2
BQE ham2

....
ham1
.....
ham2
.......



